
> frontend@0.0.0 lint
> eslint . --quiet --format json

[{"filePath":"C:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useLayers.ts","messages":[{"ruleId":"react-hooks/immutability","severity":2,"message":"Error: Cannot access variable before it is declared\n\n`createLayer` is accessed before it is declared, which prevents the earlier access from updating when this value changes over time.\n\nC:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useLayers.ts:42:7\n  40 |   useEffect(() => {\n  41 |     if (layerState.layers.length === 0) {\n> 42 |       createLayer('Background', true);\n     |       ^^^^^^^^^^^ `createLayer` accessed before it is declared\n  43 |     }\n  44 |   }, []);\n  45 |\n\nC:\\Users\\sidha\\OneDrive\\Desktop\\Software_Engineering_Project\\CollabCanvas\\frontend\\src\\hooks\\useLayers.ts:85:3\n   83 |    * Create a new layer\n   84 |    */\n>  85 |   const createLayer = useCallback((name?: string, setActive: boolean = true) => {\n      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  86 |     const newLayer: Layer = {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  87 |       id: `layer-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,\n      ΓÇª\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 104 |     return newLayer;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 105 |   }, [layerState.layers]);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `createLayer` is declared here\n  106 |\n  107 |   /**\n  108 |    * Delete a layer","line":42,"column":7,"nodeType":null,"endLine":42,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect } from 'react';\r\nimport type { Layer, LayerPanelState, DrawingElement } from '../types/canvas';\r\n\r\n/**\r\n * Default layer colors for visual distinction\r\n */\r\nconst LAYER_COLORS = [\r\n  '#3b82f6', // blue\r\n  '#ef4444', // red\r\n  '#10b981', // green\r\n  '#f59e0b', // amber\r\n  '#8b5cf6', // purple\r\n  '#ec4899', // pink\r\n  '#06b6d4', // cyan\r\n  '#84cc16', // lime\r\n  '#f97316', // orange\r\n  '#6366f1', // indigo\r\n];\r\n\r\n/**\r\n * Custom hook for managing layers\r\n * \r\n * @param elements - Array of drawing elements\r\n * @param setElements - Function to update elements\r\n */\r\nexport function useLayers(\r\n  elements: DrawingElement[],\r\n  setElements: (elements: DrawingElement[] | ((prev: DrawingElement[]) => DrawingElement[])) => void\r\n) {\r\n  const [layerState, setLayerState] = useState<LayerPanelState>({\r\n    layers: [],\r\n    activeLayerId: null,\r\n    isExpanded: true,\r\n    panelWidth: 280\r\n  });\r\n\r\n  /**\r\n   * Initialize default layer if none exist\r\n   */\r\n  useEffect(() => {\r\n    if (layerState.layers.length === 0) {\r\n      createLayer('Background', true);\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Ensure all elements have valid layerIds\r\n   */\r\n  useEffect(() => {\r\n    if (layerState.layers.length === 0 || !layerState.activeLayerId) return;\r\n\r\n    // Check if any elements are missing layerId or have invalid layerId\r\n    const needsUpdate = elements.some(el =>\r\n      !el.layerId || !layerState.layers.find(l => l.id === el.layerId)\r\n    );\r\n\r\n    if (needsUpdate) {\r\n      setElements(prev => prev.map(el => ({\r\n        ...el,\r\n        layerId: el.layerId && layerState.layers.find(l => l.id === el.layerId)\r\n          ? el.layerId\r\n          : layerState.activeLayerId!\r\n      })));\r\n    }\r\n  }, [elements, layerState.layers, layerState.activeLayerId, setElements]);\r\n\r\n  /**\r\n   * Update layer element counts\r\n   */\r\n  const updateLayerElementCounts = useCallback(() => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer => ({\r\n        ...layer,\r\n        elementIds: elements\r\n          .filter(el => el.layerId === layer.id)\r\n          .map(el => el.id)\r\n      }))\r\n    }));\r\n  }, [elements]);\r\n\r\n  /**\r\n   * Create a new layer\r\n   */\r\n  const createLayer = useCallback((name?: string, setActive: boolean = true) => {\r\n    const newLayer: Layer = {\r\n      id: `layer-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,\r\n      name: name || `Layer ${layerState.layers.length + 1}`,\r\n      visible: true,\r\n      locked: false,\r\n      opacity: 1,\r\n      blendMode: 'normal',\r\n      index: layerState.layers.length,\r\n      elementIds: [],\r\n      color: LAYER_COLORS[layerState.layers.length % LAYER_COLORS.length]\r\n    };\r\n\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: [...prev.layers, newLayer],\r\n      activeLayerId: setActive ? newLayer.id : prev.activeLayerId\r\n    }));\r\n\r\n    return newLayer;\r\n  }, [layerState.layers]);\r\n\r\n  /**\r\n   * Delete a layer\r\n   */\r\n  const deleteLayer = useCallback((layerId: string) => {\r\n    // Don't delete if it's the last layer\r\n    if (layerState.layers.length <= 1) return;\r\n\r\n    setLayerState(prev => {\r\n      const newLayers = prev.layers.filter(l => l.id !== layerId);\r\n\r\n      // Move elements from deleted layer to next available layer\r\n      const targetLayerId = newLayers[0]?.id;\r\n\r\n      if (targetLayerId) {\r\n        setElements(prevElements =>\r\n          prevElements.map(el =>\r\n            el.layerId === layerId ? { ...el, layerId: targetLayerId } : el\r\n          )\r\n        );\r\n      }\r\n\r\n      // Update indices\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers,\r\n        activeLayerId: prev.activeLayerId === layerId ? newLayers[0]?.id : prev.activeLayerId\r\n      };\r\n    });\r\n  }, [layerState.layers, setElements]);\r\n\r\n  /**\r\n   * Duplicate a layer\r\n   */\r\n  const duplicateLayer = useCallback((layerId: string) => {\r\n    const sourceLayer = layerState.layers.find(l => l.id === layerId);\r\n    if (!sourceLayer) return;\r\n\r\n    // Create new layer\r\n    const newLayer: Layer = {\r\n      ...sourceLayer,\r\n      id: `layer-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,\r\n      name: `${sourceLayer.name} (copy)`,\r\n      index: sourceLayer.index + 1,\r\n      elementIds: []\r\n    };\r\n\r\n    // Duplicate elements from source layer\r\n    const elementsToDuplicate = elements.filter(el => el.layerId === layerId);\r\n    const newElements = elementsToDuplicate.map(el => ({\r\n      ...el,\r\n      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n      layerId: newLayer.id,\r\n      x: (el.x || 0) + 20, // Offset by 20px\r\n      y: (el.y || 0) + 20\r\n    }));\r\n\r\n    // Add new elements\r\n    setElements(prev => [...prev, ...newElements]);\r\n\r\n    // Update layers\r\n    setLayerState(prev => {\r\n      const newLayers = [...prev.layers];\r\n      newLayers.splice(sourceLayer.index + 1, 0, newLayer);\r\n\r\n      // Update indices of subsequent layers\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers,\r\n        activeLayerId: newLayer.id\r\n      };\r\n    });\r\n  }, [layerState.layers, elements, setElements]);\r\n\r\n  /**\r\n   * Toggle layer visibility\r\n   */\r\n  const toggleLayerVisibility = useCallback((layerId: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, visible: !layer.visible }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Toggle layer lock\r\n   */\r\n  const toggleLayerLock = useCallback((layerId: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, locked: !layer.locked }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Set active layer\r\n   */\r\n  const setActiveLayer = useCallback((layerId: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      activeLayerId: layerId\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Rename layer\r\n   */\r\n  const renameLayer = useCallback((layerId: string, newName: string) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, name: newName }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Change layer opacity\r\n   */\r\n  const setLayerOpacity = useCallback((layerId: string, opacity: number) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, opacity }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Change layer blend mode\r\n   */\r\n  const setLayerBlendMode = useCallback((layerId: string, blendMode: Layer['blendMode']) => {\r\n    setLayerState(prev => ({\r\n      ...prev,\r\n      layers: prev.layers.map(layer =>\r\n        layer.id === layerId\r\n          ? { ...layer, blendMode }\r\n          : layer\r\n      )\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Reorder layers (drag and drop)\r\n   */\r\n  const reorderLayers = useCallback((sourceIndex: number, targetIndex: number) => {\r\n    if (sourceIndex === targetIndex) return;\r\n\r\n    setLayerState(prev => {\r\n      const newLayers = [...prev.layers];\r\n      const [movedLayer] = newLayers.splice(sourceIndex, 1);\r\n      newLayers.splice(targetIndex, 0, movedLayer);\r\n\r\n      // Update indices\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers\r\n      };\r\n    });\r\n  }, []);\r\n\r\n  /**\r\n   * Merge layer down\r\n   */\r\n  const mergeLayerDown = useCallback((layerId: string) => {\r\n    const layerIndex = layerState.layers.findIndex(l => l.id === layerId);\r\n    if (layerIndex <= 0) return; // Can't merge the bottom layer\r\n\r\n    const targetLayer = layerState.layers[layerIndex];\r\n    const bottomLayer = layerState.layers[layerIndex - 1];\r\n\r\n    // Move all elements from target layer to bottom layer\r\n    setElements(prev =>\r\n      prev.map(el =>\r\n        el.layerId === targetLayer.id\r\n          ? { ...el, layerId: bottomLayer.id }\r\n          : el\r\n      )\r\n    );\r\n\r\n    // Remove target layer\r\n    setLayerState(prev => {\r\n      const newLayers = prev.layers.filter((_, idx) => idx !== layerIndex);\r\n      newLayers.forEach((layer, idx) => {\r\n        layer.index = idx;\r\n      });\r\n\r\n      return {\r\n        ...prev,\r\n        layers: newLayers,\r\n        activeLayerId: bottomLayer.id\r\n      };\r\n    });\r\n  }, [layerState.layers, setElements]);\r\n\r\n  /**\r\n   * Get elements for a specific layer (considering visibility)\r\n   */\r\n  const getLayerElements = useCallback((layerId: string): DrawingElement[] => {\r\n    const layer = layerState.layers.find(l => l.id === layerId);\r\n    if (!layer || !layer.visible) return [];\r\n\r\n    return elements.filter(el => el.layerId === layerId);\r\n  }, [elements, layerState.layers]);\r\n\r\n  /**\r\n   * Check if a layer is editable (visible and not locked)\r\n   */\r\n  const isLayerEditable = useCallback((layerId: string): boolean => {\r\n    const layer = layerState.layers.find(l => l.id === layerId);\r\n    return layer ? layer.visible && !layer.locked : false;\r\n  }, [layerState.layers]);\r\n\r\n  return {\r\n    layerState,\r\n    createLayer,\r\n    deleteLayer,\r\n    duplicateLayer,\r\n    toggleLayerVisibility,\r\n    toggleLayerLock,\r\n    setActiveLayer,\r\n    renameLayer,\r\n    setLayerOpacity,\r\n    setLayerBlendMode,\r\n    reorderLayers,\r\n    mergeLayerDown,\r\n    getLayerElements,\r\n    isLayerEditable,\r\n    updateLayerElementCounts,\r\n    setLayerState\r\n  };\r\n}","usedDeprecatedRules":[]}]
